# Nalgebra - Dynamic Linear Algebra Library for Nostos
#
# This module provides dynamic-sized vector and matrix operations
# using the native nalgebra extension.
#
# Usage:
#   import nalgebra
#
#   v1 = nalgebra.vec([1.0, 2.0, 3.0, 4.0, 5.0])
#   v2 = nalgebra.vec([5.0, 4.0, 3.0, 2.0, 1.0])
#   sum = v1 + v2    # Operator overloading!
#   diff = v1 - v2
#   prod = v1 * v2   # Component-wise multiplication
#
#   m1 = nalgebra.mat([[1.0, 2.0], [3.0, 4.0]])
#   m2 = nalgebra.mat([[5.0, 6.0], [7.0, 8.0]])
#   product = m1 * m2  # Matrix multiplication

# =============================================================================
# Vec Type - Dynamic Vector with Operator Overloading
# =============================================================================

# Native handle wrapper - data stores the native pointer
pub type Vec = { data: Any }

trait Num
    add(self, other: Self) -> Self
    sub(self, other: Self) -> Self
    mul(self, other: Self) -> Self
    div(self, other: Self) -> Self
end

Vec: Num
    add(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecAdd", self.data, other.data))
    sub(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecSub", self.data, other.data))
    mul(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecMap", self.data, other.data))
    div(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecDiv", self.data, other.data))
end

# Vec constructor - creates native handle from list
pub vec(data: List) -> Vec = Vec(__native__("Nalgebra.dvec", data))

# Vec factory functions
pub vecZeros(n: Int) -> Vec = Vec(__native__("Nalgebra.dvecZeros", n))
pub vecOnes(n: Int) -> Vec = Vec(__native__("Nalgebra.dvecOnes", n))

# Vec operations
pub vecDot(a: Vec, b: Vec) -> Float = __native__("Nalgebra.dvecDot", a.data, b.data)
pub vecNorm(v: Vec) -> Float = __native__("Nalgebra.dvecNorm", v.data)
pub vecNormalize(v: Vec) -> Vec = Vec(__native__("Nalgebra.dvecNormalize", v.data))
pub vecLen(v: Vec) -> Int = __native__("Nalgebra.dvecLen", v.data)
pub vecGet(v: Vec, i: Int) -> Float = __native__("Nalgebra.dvecGet", v.data, i)
pub vecSet(v: Vec, i: Int, val: Float) -> Vec = Vec(__native__("Nalgebra.dvecSet", v.data, i, val))
pub vecSum(v: Vec) -> Float = __native__("Nalgebra.dvecSum", v.data)
pub vecMin(v: Vec) -> Float = __native__("Nalgebra.dvecMin", v.data)
pub vecMax(v: Vec) -> Float = __native__("Nalgebra.dvecMax", v.data)
pub vecScale(v: Vec, s: Float) -> Vec = Vec(__native__("Nalgebra.dvecScale", v.data, s))
pub vecDistance(a: Vec, b: Vec) -> Float = __native__("Nalgebra.dvecNorm", __native__("Nalgebra.dvecSub", b.data, a.data))
pub vecLerp(a: Vec, b: Vec, t: Float) -> Vec = a + vecScale(b - a, t)
pub vecToList(v: Vec) -> List = __native__("Nalgebra.dvecToList", v.data)

# =============================================================================
# Mat Type - Dynamic Matrix with Operator Overloading
# =============================================================================

# Native handle wrapper - data stores the native pointer
pub type Mat = { data: Any }

Mat: Num
    add(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatAdd", self.data, other.data))
    sub(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatSub", self.data, other.data))
    mul(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatMul", self.data, other.data))
    div(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatMul", self.data, __native__("Nalgebra.dmatInverse", other.data)))
end

# Mat constructor - creates native handle from nested list
pub mat(data: List) -> Mat = Mat(__native__("Nalgebra.dmat", data))

# Mat factory functions
pub matIdentity(n: Int) -> Mat = Mat(__native__("Nalgebra.dmatIdentity", n))
pub matZeros(rows: Int, cols: Int) -> Mat = Mat(__native__("Nalgebra.dmatZeros", rows, cols))
pub matOnes(rows: Int, cols: Int) -> Mat = Mat(__native__("Nalgebra.dmatOnes", rows, cols))
pub matFromRows(rows: List) -> Mat = Mat(__native__("Nalgebra.dmatFromRows", rows))
pub matFromCols(cols: List) -> Mat = Mat(__native__("Nalgebra.dmatFromCols", cols))
pub matDiag(v: Vec) -> Mat = Mat(__native__("Nalgebra.dmatDiag", v.data))

# Mat operations
pub matRows(m: Mat) -> Int = __native__("Nalgebra.dmatRows", m.data)
pub matCols(m: Mat) -> Int = __native__("Nalgebra.dmatCols", m.data)
pub matGet(m: Mat, row: Int, col: Int) -> Float = __native__("Nalgebra.dmatGet", m.data, row, col)
pub matSet(m: Mat, row: Int, col: Int, val: Float) -> Mat = Mat(__native__("Nalgebra.dmatSet", m.data, row, col, val))
pub matTranspose(m: Mat) -> Mat = Mat(__native__("Nalgebra.dmatTranspose", m.data))
pub matTrace(m: Mat) -> Float = __native__("Nalgebra.dmatTrace", m.data)
pub matDeterminant(m: Mat) -> Float = __native__("Nalgebra.dmatDeterminant", m.data)
pub matInverse(m: Mat) -> Mat = Mat(__native__("Nalgebra.dmatInverse", m.data))
pub matScale(m: Mat, s: Float) -> Mat = Mat(__native__("Nalgebra.dmatScale", m.data, s))
pub matPow(m: Mat, n: Int) -> Mat = Mat(__native__("Nalgebra.dmatPow", m.data, n))
pub matMulVec(m: Mat, v: Vec) -> Vec = Vec(__native__("Nalgebra.dmatMulVec", m.data, v.data))
pub matGetRow(m: Mat, row: Int) -> Vec = Vec(__native__("Nalgebra.dmatGetRow", m.data, row))
pub matGetCol(m: Mat, col: Int) -> Vec = Vec(__native__("Nalgebra.dmatGetCol", m.data, col))
pub matIsSquare(m: Mat) -> Bool = matRows(m) == matCols(m)
pub matShape(m: Mat) -> (Int, Int) = (matRows(m), matCols(m))
pub matToList(m: Mat) -> List = __native__("Nalgebra.dmatToList", m.data)

# Nalgebra - Dynamic Linear Algebra Library for Nostos
#
# This module provides dynamic-sized vector and matrix operations
# using the native nalgebra extension. Unlike glam (fixed Vec2-4),
# nalgebra supports arbitrary-length vectors and matrices.
#
# Usage:
#   import nalgebra
#
#   v1 = nalgebra.Vec([1.0, 2.0, 3.0, 4.0, 5.0])
#   v2 = nalgebra.Vec([5.0, 4.0, 3.0, 2.0, 1.0])
#   sum = v1 + v2    # Operator overloading!
#   diff = v1 - v2
#   scaled = v1 * 2.0
#
#   m = nalgebra.Mat.identity(3)
#   det = m.determinant()

# =============================================================================
# Vec Type - Dynamic Vector with Operator Overloading
# =============================================================================

pub type Vec = { data: List Float }

trait Num
    add(self, other: Self) -> Self
    sub(self, other: Self) -> Self
    mul(self, other: Self) -> Self
    div(self, other: Self) -> Self
end

Vec: Num
    add(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecAdd", self.data, other.data))
    sub(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecSub", self.data, other.data))
    mul(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecMap", self.data, other.data))
    div(self, other: Vec) -> Vec = Vec(__native__("Nalgebra.dvecDiv", self.data, other.data))
end

# Vec methods
pub Vec.zeros(n) = Vec(__native__("Nalgebra.dvecZeros", n))
pub Vec.ones(n) = Vec(__native__("Nalgebra.dvecOnes", n))
pub Vec.dot(self, other: Vec) -> Float = __native__("Nalgebra.dvecDot", self.data, other.data)
pub Vec.norm(self) -> Float = __native__("Nalgebra.dvecNorm", self.data)
pub Vec.normalize(self) -> Vec = Vec(__native__("Nalgebra.dvecNormalize", self.data))
pub Vec.len(self) -> Int = __native__("Nalgebra.dvecLen", self.data)
pub Vec.get(self, i: Int) -> Float = __native__("Nalgebra.dvecGet", self.data, i)
pub Vec.sum(self) -> Float = __native__("Nalgebra.dvecSum", self.data)
pub Vec.min(self) -> Float = __native__("Nalgebra.dvecMin", self.data)
pub Vec.max(self) -> Float = __native__("Nalgebra.dvecMax", self.data)
pub Vec.scale(self, s: Float) -> Vec = Vec(__native__("Nalgebra.dvecScale", self.data, s))
pub Vec.distance(self, other: Vec) -> Float = __native__("Nalgebra.dvecNorm", __native__("Nalgebra.dvecSub", other.data, self.data))

# =============================================================================
# Mat Type - Dynamic Matrix with Operator Overloading
# =============================================================================

pub type Mat = { data: List (List Float) }

Mat: Num
    add(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatAdd", self.data, other.data))
    sub(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatSub", self.data, other.data))
    mul(self, other: Mat) -> Mat = Mat(__native__("Nalgebra.dmatMul", self.data, other.data))
    div(self, other: Mat) -> Mat = self * other.inverse()
end

# Mat constructors
pub Mat.identity(n) = Mat(__native__("Nalgebra.dmatIdentity", n))
pub Mat.zeros(rows, cols) = Mat(__native__("Nalgebra.dmatZeros", rows, cols))
pub Mat.ones(rows, cols) = Mat(__native__("Nalgebra.dmatOnes", rows, cols))

# Mat methods
pub Mat.rows(self) -> Int = __native__("Nalgebra.dmatRows", self.data)
pub Mat.cols(self) -> Int = __native__("Nalgebra.dmatCols", self.data)
pub Mat.get(self, row: Int, col: Int) -> Float = __native__("Nalgebra.dmatGet", self.data, row, col)
pub Mat.transpose(self) -> Mat = Mat(__native__("Nalgebra.dmatTranspose", self.data))
pub Mat.trace(self) -> Float = __native__("Nalgebra.dmatTrace", self.data)
pub Mat.determinant(self) -> Float = __native__("Nalgebra.dmatDeterminant", self.data)
pub Mat.inverse(self) -> Mat = Mat(__native__("Nalgebra.dmatInverse", self.data))
pub Mat.scale(self, s: Float) -> Mat = Mat(__native__("Nalgebra.dmatScale", self.data, s))
pub Mat.pow(self, n: Int) -> Mat = Mat(__native__("Nalgebra.dmatPow", self.data, n))
pub Mat.mulVec(self, v: Vec) -> Vec = Vec(__native__("Nalgebra.dmatMulVec", self.data, v.data))
pub Mat.getRow(self, row: Int) -> Vec = Vec(__native__("Nalgebra.dmatGetRow", self.data, row))
pub Mat.getCol(self, col: Int) -> Vec = Vec(__native__("Nalgebra.dmatGetCol", self.data, col))

# =============================================================================
# DVector - Dynamic-Sized Vector Operations
# =============================================================================

# Create a dynamic vector from a list
pub dvec(list) = __native__("Nalgebra.dvec", list)

# Create a zero vector of length n
pub dvecZeros(n) = __native__("Nalgebra.dvecZeros", n)

# Create a vector of ones of length n
pub dvecOnes(n) = __native__("Nalgebra.dvecOnes", n)

# Add two DVectors
pub dvecAdd(a, b) = __native__("Nalgebra.dvecAdd", a, b)

# Subtract two DVectors
pub dvecSub(a, b) = __native__("Nalgebra.dvecSub", a, b)

# Multiply DVector by scalar
pub dvecScale(v, s) = __native__("Nalgebra.dvecScale", v, s)

# Dot product of two DVectors
pub dvecDot(a, b) = __native__("Nalgebra.dvecDot", a, b)

# Euclidean norm (length) of DVector
pub dvecNorm(v) = __native__("Nalgebra.dvecNorm", v)

# Normalize DVector to unit length
pub dvecNormalize(v) = __native__("Nalgebra.dvecNormalize", v)

# Get the length (number of elements) of DVector
pub dvecLen(v) = __native__("Nalgebra.dvecLen", v)

# Get element at index i
pub dvecGet(v, i) = __native__("Nalgebra.dvecGet", v, i)

# Set element at index i (returns new vector)
pub dvecSet(v, i, val) = __native__("Nalgebra.dvecSet", v, i, val)

# Component-wise (Hadamard) multiplication of two DVectors
pub dvecComponentMul(a, b) = __native__("Nalgebra.dvecMap", a, b)

# Sum of all elements
pub dvecSum(v) = __native__("Nalgebra.dvecSum", v)

# Minimum element
pub dvecMin(v) = __native__("Nalgebra.dvecMin", v)

# Maximum element
pub dvecMax(v) = __native__("Nalgebra.dvecMax", v)

# =============================================================================
# DMatrix - Dynamic-Sized Matrix Operations
# =============================================================================

# Create a matrix from nested list (row-major)
# Example: dmat([[1,2], [3,4]]) creates 2x2 matrix
pub dmat(rows) = __native__("Nalgebra.dmat", rows)

# Create n x n identity matrix
pub dmatIdentity(n) = __native__("Nalgebra.dmatIdentity", n)

# Create rows x cols zero matrix
pub dmatZeros(rows, cols) = __native__("Nalgebra.dmatZeros", rows, cols)

# Create rows x cols matrix of ones
pub dmatOnes(rows, cols) = __native__("Nalgebra.dmatOnes", rows, cols)

# Create matrix from list of row vectors
pub dmatFromRows(rows) = __native__("Nalgebra.dmatFromRows", rows)

# Create matrix from list of column vectors
pub dmatFromCols(cols) = __native__("Nalgebra.dmatFromCols", cols)

# Add two matrices
pub dmatAdd(a, b) = __native__("Nalgebra.dmatAdd", a, b)

# Subtract two matrices
pub dmatSub(a, b) = __native__("Nalgebra.dmatSub", a, b)

# Matrix multiplication
pub dmatMul(a, b) = __native__("Nalgebra.dmatMul", a, b)

# Matrix-vector multiplication
pub dmatMulVec(m, v) = __native__("Nalgebra.dmatMulVec", m, v)

# Multiply matrix by scalar
pub dmatScale(m, s) = __native__("Nalgebra.dmatScale", m, s)

# Transpose matrix
pub dmatTranspose(m) = __native__("Nalgebra.dmatTranspose", m)

# Get number of rows
pub dmatRows(m) = __native__("Nalgebra.dmatRows", m)

# Get number of columns
pub dmatCols(m) = __native__("Nalgebra.dmatCols", m)

# Get element at (row, col)
pub dmatGet(m, row, col) = __native__("Nalgebra.dmatGet", m, row, col)

# Set element at (row, col) (returns new matrix)
pub dmatSet(m, row, col, val) = __native__("Nalgebra.dmatSet", m, row, col, val)

# Get row as vector
pub dmatGetRow(m, row) = __native__("Nalgebra.dmatGetRow", m, row)

# Get column as vector
pub dmatGetCol(m, col) = __native__("Nalgebra.dmatGetCol", m, col)

# Trace (sum of diagonal elements) - only for square matrices
pub dmatTrace(m) = __native__("Nalgebra.dmatTrace", m)

# Determinant - only for square matrices
pub dmatDeterminant(m) = __native__("Nalgebra.dmatDeterminant", m)

# Matrix inverse - only for square, non-singular matrices
pub dmatInverse(m) = __native__("Nalgebra.dmatInverse", m)

# =============================================================================
# Convenience Functions
# =============================================================================

# Distance between two points (as DVectors)
pub dvecDistance(a, b) = dvecNorm(dvecSub(b, a))

# Linear interpolation between two DVectors
# Returns a + t * (b - a)
pub dvecLerp(a, b, t) = dvecAdd(a, dvecScale(dvecSub(b, a), t))

# Create a diagonal matrix from a vector
# Note: Use __native__ call directly for complex iteration
pub dmatDiag(v) = __native__("Nalgebra.dmatDiag", v)

# Matrix power (positive integer only)
pub dmatPow(m, n) = __native__("Nalgebra.dmatPow", m, n)

# Check if matrix is square
pub dmatIsSquare(m) = dmatRows(m) == dmatCols(m)

# Get matrix shape as tuple
pub dmatShape(m) = (dmatRows(m), dmatCols(m))
